## ビルド方法

```
$ docker build -t my-golang-app .
$ docker run -it --rm --name my-running-app my-golang-app
```

## Basic Syntax
https://gobyexample.com/hello-world

## Variables and declaration
https://gobyexample.com/variables

## varのメリット
Go言語における `var` キーワードを使って変数を宣言する方法には以下のような利点があります。

1. **型の明示**: `var` を使うと、変数の型を明示的に指定できます。これは、コードの可読性を高め、期待する型が何であるかを他の開発者に示すために有用です。

```go
var count int
```

2. **初期値を明示しない宣言**: `var` を使用すると、変数に初期値を設定せずに宣言することができます。これは、後でその変数に値を設定するケースにおいて有用です。初期値なしで宣言された変数は、その型のゼロ値で初期化されます（例えば、int型であれば0、string型であれば空文字("")など）。

```go
var name string
var count int
```

3. **一度に複数の変数を宣言**: `var` を使用して一度に複数の変数を宣言することも可能です。これはコードの整理と一貫性のために有用です。

```go
var (
  name string
  age  int
)
```

4. **パッケージレベルでの変数宣言**: `var` はパッケージレベルでの変数宣言を可能にします。これは、関数の外部で変数を宣言し、パッケージ全体からアクセスできるようにするために必要です。

```go
var PackageLevelVariable int
```

これらの理由から、`var` キーワードは Go 言語のコードの多くの部分で重要な役割を果たします。

### varを利用せずに変数宣言する方法
Go言語では `:=` 演算子を使用して `var` キーワードを使わずに変数を宣言できます。この方法は特に変数の初期化を同時に行いたい場合に便利で、型推論を用いて変数の型を自動的に決定します。

ここに例を示します：

```go
i := 10 // i は int 型
s := "hello" // s は string 型
f := 3.1415 // f は float64 型
```

この方法では、変数の型を明示的に指定する必要がなく、コンパイラが右辺の値から型を推論します。

ただし、この方法は関数の中でのみ使用でき、パッケージレベルでは使うことができません。また、既に宣言された変数に対しては `:=` を使用せず `=` を使って値を再代入する必要があります。

これらの点に注意しながら、`:=` 演算子を使った変数宣言は、Goのコードを短く読みやすくするのに役立ちます。

### varと:=の使い分け
`var`と`:=`のどちらが良く利用されるかは、具体的な状況やコーディングスタイルによります。それぞれが異なる用途と利点を持っています。

`:=`は主に以下のような状況で用いられます:

- 関数内でのみ使用し、変数の初期化を同時に行いたい場合。
- コンパイラによる型推論を利用して、コードを短く読みやすくしたい場合。

一方、`var`は以下のような場合によく用いられます:

- 初期値を指定せずに変数を宣言したい場合。
- パッケージレベルで変数を宣言したい場合。
- 一度に複数の変数を宣言したい場合。

`:=`は型宣言が不要で、より短いコードで変数宣言と初期化ができるため、多くのGoのコーダーによって好まれます。しかし、あくまでこれは一般的な傾向であり、どちらを使用するべきかは個々の状況やプロジェクトのコーディング規範による部分も大きいです。

## Data Types
Go言語には、以下のような多数のデータ型があります。

**基本型（Basic types）**

1. `bool`: 真偽値を表す論理型。値は `true` または `false`。

2. `string`: 文字列を表す型。

3. `int`、`int8`、`int16`、`int32`、`int64`: 符号付き整数を表す型。`int`は特にプラットフォームに依存し、32ビットシステムでは`int32`と同等、64ビットシステムでは`int64`と同等になります。

4. `uint`、`uint8`、`uint16`、`uint32`、`uint64`: 符号なし（非負）整数を表す型。`uint`も`int`同様プラットフォームに依存します。

5. `byte`: `uint8`の別名として使われることが多く、主にバイナリデータを扱うのに用いられます。

6. `rune`: `int32`の別名で、主にUnicodeのコードポイントを扱うのに用いられます。

7. `float32`、`float64`: 浮動小数点数を表す型。

8. `complex64`、`complex128`: 複素数を表す型。

**集合型（Aggregate types）**

1. `array`: 固定長の配列。配列の長さも型の一部となります。

2. `slice`: 可変長の配列。配列と違い、スライスの長さは型の一部ではありません。

3. `map`: キーと値のペアを保持するハッシュマップ。キーは任意の型、値も任意の型が可能です。

4. `struct`: 複数のフィールドを持つ複合データ型。各フィールドはそれぞれ名前と型を持ちます。

**参照型（Reference types）**

1. `pointer`: 他の型の値への参照（ポインタ）を保持する型。

2. `channel`: ゴルーチン間でデータを送受信するための通信メカニズム。

**インターフェース型（Interface types）**

1. `interface`: メソッドシグニチャの集まりを定義する型。

上記がGoの基本的なデータ型となりますが、さらにこれらを組み合わせて複雑なデータ構造を定義することも可能です。また、`type`キーワードを使って既存の型から新しい型を定義することもできます。

### int、int8、int16、int32、int64　の使い分け
Go言語における`int`、`int8`、`int16`、`int32`、`int64`といった型の使い分けは、主に次のような要素に依存します。

1. **保存したい数値のサイズ**: `int8`は-128から127まで、`int16`は-32,768から32,767まで、`int32`は-2,147,483,648から2,147,483,647まで、`int64`は非常に大きな負の数から非常に大きな正の数までを表すことができます。したがって、保存したい整数の範囲に基づいて適切な型を選択します。

2. **メモリの使用量**: `int8`、`int16`、`int32`、`int64`はそれぞれ8ビット、16ビット、32ビット、64ビットのメモリを使用します。大量のデータを扱う場合やメモリを節約したい場合には、小さいサイズの整数型を選ぶことが有効です。

3. **互換性と移植性**: `int`型は特定のプラットフォームに依存します。つまり、32ビットシステムでは`int32`と同等で、64ビットシステムでは`int64`と同等です。したがって、特定のサイズを必要としない場合や、プログラムを異なるアーキテクチャ間で移植可能に保つ必要がある場合には、`int`型を使用すると良いでしょう。

4. **外部APIやライブラリとの互換性**: 外部のAPIやライブラリが特定の整数型を要求する場合もあります。そのような場合には、そのAPIやライブラリと互換性を持つ型を選択します。

以上のような観点から適切な型を選択することで、プログラムの効率性、可読性、および安全性を向上させることができます。

> つまり、int16を利用すると16bitのメモリ空間が予約されるので、8bitで足りる場合は余計にメモリを利用しているということでしょうか。

はい、その通りです。それぞれの整数型`int8`、`int16`、`int32`、`int64`は、名前に示されている通り、それぞれ8ビット、16ビット、32ビット、64ビットのメモリ空間を使用します。

したがって、例えば-128から127までの値を保持するためだけに`int16`や`int32`を使用すると、必要以上にメモリを消費することになります。そのような値の範囲では、`int8`が最もメモリ効率的な選択となります。

ただし、実際のところ現代のコンピュータシステムにおいては、このようなメモリの使用量の違いがパフォーマンスに大きな影響を与えることは少ないです。なぜなら、多くの現代のプロセッサは自然なアライメント（通常は32ビットまたは64ビット）でデータを効率的に操作するよう設計されているからです。

しかし、大量のデータ（例えば、数百万の要素からなる配列）を扱う場合や、メモリが限られているシステム（組み込みシステムなど）で動作するソフトウェアを開発する場合には、より小さい整数型を使用することでメモリの節約に繋がることもあります。

### uint、uint8、uint16、uint32、uint64はどのような時に利用されますか？
`uint`, `uint8`, `uint16`, `uint32`, `uint64` などの符号なし整数型は、負の数を含まない整数を扱いたいときに利用されます。以下にいくつかの典型的なケースを紹介します。

1. **範囲が自然数のみのカウンタ**: 負の値を取り得ないカウンタやインデックスには `uint` やその他の符号なし整数型を使うことが適切です。例えば、配列やスライスのインデックスや、ループカウンタには通常 `uint` や `int` が使用されます。

2. **ビット操作**: `uint` 型の各ビットにフラグを格納したり、ビットマスクを使用したり、ビットシフトを行うような操作を必要とする場合、`uint` 型やその他の符号なし整数型は特に有用です。

3. **バイトデータの操作**: バイトデータ（文字列のバイト、ファイルの内容など）を操作する際には、`uint8`（`byte`としても知られる）がよく使用されます。

4. **外部システムとの互換性**: 外部のシステムやライブラリ、APIが特定の符号なし整数型を要求する場合もあります。そのような場合、そのAPIやライブラリと互換性を持つ型を選択する必要があります。

また、`uint` の使用は `int` と同様で、プラットフォームに依存します。つまり、32ビットシステムでは `uint32` と同等、64ビットシステムでは `uint64` と同等になります。したがって、特定のサイズを必要としない場合や、プログラムを異なるアーキテクチャ間で移植可能に保つ必要がある場合には、 `uint` 型を使用すると良いでしょう。

> 64ビット幅のメモリアドレスとは？
メモリアドレスとは、コンピュータの物理メモリ（RAM）内の特定の場所を指す一意の識別子です。それぞれのメモリセル（通常は1バイト）は一意のアドレスを持っています。コンピュータのプログラムは、これらのアドレスを使用してメモリからデータを読み取ったり、メモリにデータを書き込んだりします。

64ビット幅のメモリアドレスとは、64ビット（つまり64個の二進数の桁）で表現されるメモリアドレスのことを指します。64ビットのメモリアドレスを使用すると、2の64乗、つまり約1.8 * 10^19個の異なるメモリアドレスを表現することができます。これは16エクサバイト（1エクサバイトは約1億ギガバイト）のメモリに相当します。

これに対して、32ビットシステムではメモリアドレスは32ビットで表現され、2の32乗、つまり約43億の異なるメモリアドレス（約4ギガバイトのメモリ）を表現することができます。

したがって、64ビットシステムでは、32ビットシステムと比べてはるかに多くのメモリにアクセスできます。これが64ビットアーキテクチャの一つの主要な利点です。

### byteとは
Go言語では、`byte`は`uint8`のエイリアス（同義語）です。つまり、`byte`型は`uint8`と同じで、8ビット（1バイト）の符号なし整数を表します。

バイトはコンピュータがデータを表現する基本的な単位で、1バイトは8ビットから成ります。`byte`型は、小さな数値、ASCII文字、バイナリデータなどを表すのによく使われます。

例えば、Go言語では以下のように`byte`型を使うことができます：

```go
var b byte = 'A'
fmt.Println(b) // 65を出力（'A'のASCIIコード）
```

また、文字列の各文字（ASCII文字の場合）をバイトとして扱うこともできます：

```go
s := "Hello, World!"
for i := 0; i < len(s); i++ {
    fmt.Printf("%c ", s[i]) // 各文字を出力
}
```
> 利用例
`byte`型はさまざまな場面で使われますが、以下にいくつか典型的な使用例を挙げます：

1. **バイナリデータの操作**: `byte`型はバイナリデータを操作する際によく使用されます。たとえば、ファイルからバイナリデータを読み込んだり、ネットワークを介してバイナリデータを送受信したりする場合、そのデータは通常`byte`のスライス（`[]byte`）として表現されます。

2. **文字列の操作**: Goでは、文字列は基本的に`byte`のシーケンスとして扱われます（具体的には、UTF-8でエンコードされた`byte`のシーケンス）。したがって、文字列を1文字ずつ処理したり、文字列内の特定のバイトを変更したりする場合、`byte`型が使用されます。

3. **暗号化とハッシュ**: 暗号化ライブラリやハッシュ関数では、通常、入力と出力を`byte`のスライスとして扱います。これは、これらの操作がバイナリデータに対して行われるからです。

4. **低レベルなプログラミング**: `byte`型は、ハードウェアと直接通信するような低レベルのプログラミングでよく使われます。たとえば、I/Oポートからのデータの読み取りや、カスタムデバイスとの通信などです。

以上のような場面で`byte`型が使用されますが、その他にも多くの場面で`byte`型は利用されます。基本的に、バイナリデータや文字列データを操作する際には、`byte`型が使われることが多いです。

> 1byte=8bitはネットワークにおける最小単位なのですか？
ネットワークでのデータの送受信においては、最小単位はビット(bit)です。1ビットは、0または1の値を持つ最小のデータ単位です。これは、通信の基本的な性質（デジタル信号が2つの状態、つまり0と1を使って情報を表現する）に由来します。

しかし、プログラミングにおいては、最小の扱いやすい単位はバイト(byte)です。1バイトは8ビットから成り、これはASCII文字など多くの基本的なデータを表現するのに適しています。また、現代のコンピュータアーキテクチャでは、バイトはメモリの最小アドレス可能単位です。

そのため、バイトは多くの場面で基本的な操作単位として使われます。たとえば、ファイルからのデータの読み書きやネットワーク通信などでは、通常はバイトの配列（あるいはその他のバイトの集合を表現するデータ構造）が使われます。

ですので、ビットがネットワーク通信の最小単位である一方、バイトはプログラミングやデータ操作の最小単位と言えます。

> バイトで送受信し、適切な型に変換する。これはどういう意味でしょうか？
"バイトで送受信し、適切な型に変換する"という表現は、データの送受信とその処理に関する一般的なパターンを指しています。

ネットワーク通信やファイル操作などでは、データはバイナリ形式、つまりバイトのシーケンスとして送受信されます。これは、バイトがコンピュータで最も広く使われるデータの基本単位であり、あらゆる種類のデータを表現することができるからです。

一方、実際のアプリケーションのロジックでは、データは通常、より高レベルの型（整数、浮動小数点数、文字列、構造体など）として扱われます。これらの型は、プログラムのロジックをより直感的に、また効率的に記述するために必要です。

したがって、ネットワークから受信したデータ（バイトのシーケンス）をアプリケーションが理解できる形式（適切な型）に変換する必要があります。同様に、アプリケーションから送信するデータも、適切な型からバイトのシーケンスに変換する必要があります。

この変換プロセスは、しばしば「シリアライゼーション（またはマーシャリング）」と「デシリアライゼーション（またはアンマーシャリング）」と呼ばれます。

例えば、Go言語では、整数をバイトのシーケンスに変換するには`binary`パッケージの`binary.PutUvarint`関数を、バイトのシーケンスを整数に変換するには`binary.Uvarint`関数を使用します。これにより、整数をネットワーク経由で送受信することができます。

このように、"バイトで送受信し、適切な型に変換する"という表現は、この一連のプロセスを指しています。

> なるほど、アプリケーションなどで利用される文字などの構成要素としては、バイトのシーケンスが多いため、16bitで扱うと文字化けなどを引き起こしたり、正しく文字に変換できないので、最小単位の8bitを利用しましょうということでしょうか？utf16などもbyteで扱えるのですか？
そうです、8ビットのバイトが最も基本的なデータ単位で、全てのデータが最終的にはバイトのシーケンスとして表現されます。16ビットや32ビットの値を直接送受信すると、エンディアンの問題や文字化けなどの問題が起きる可能性があります。これらの問題を避けるため、また送受信するデータを一貫して扱うために、通常はバイトのシーケンスとして送受信します。

UTF-16などの他のエンコーディングも、最終的にはバイトのシーケンスとして表現されます。UTF-16は16ビット（2バイト）の単位で文字を表現しますが、これをバイトのシーケンスとして扱うことができます。たとえば、'A' は UTF-16 では 0x0041 と表現され、これはバイトのシーケンス 0x41, 0x00（または 0x00, 0x41、エンディアンによる）として表現できます。

Go言語では、`unicode/utf16`パッケージを使用してUTF-16エンコーディングとデコーディングを行うことができます。このパッケージでは、UTF-16文字を16ビットの整数のスライスとして扱いますが、これをバイトのスライスに変換することも可能です。

したがって、データの送受信やファイルの読み書きを行う際には、バイトのシーケンスを使用し、その上で適切なエンコーディング/デコーディングを行うことが一般的です。

>なるほど、最小単位1bit単位で扱うことはできるが、効率的ではないということであってますか？それで8bitを基本単位として扱っている仕様が多いので、それに合わせてbyte単位で送受信を行い、アプリケーション側でエンコーディングとデコーディングを行う
その通りです。実際には、1ビット単位でデータを直接扱うことは非常にまれで、それは非効率的であるからです。それは、ハードウェアレベルではメモリはバイト単位でアドレスが割り当てられ、CPUもバイト単位（またはそれ以上の単位）でデータを操作するためです。

8ビット（1バイト）はコンピュータアーキテクチャの標準的な単位で、最も一般的に使われているデータ単位です。そのため、ほとんどのデータ（テキスト、画像、音声、ビデオなど）はバイトのシーケンスとして表現され、バイト単位で送受信されます。

そしてアプリケーション側では、受信したバイトのシーケンスを適切なデータ型にデコード（または変換）し、送信する前にデータをバイトのシーケンスにエンコード（または変換）します。

このように、バイト単位でデータを扱うことは、コンピュータシステムの基本的な仕組みに基づいており、また効率的なデータ処理を可能にします。

>ああ！メモリはバイト単位でアドレスが区切られているんですね！それに合わせて送受信もバイトシーケンスで行っているのですか？それともバイトシーケンスで扱うからメモリはバイト単位で区切られているのですか？どっちが先ですか？
コンピュータのメモリは、元々バイト単位でアドレスが割り当てられるように設計されています。その理由の一つは、バイト（8ビット）が多くのタイプの情報（文字、数値など）を表現するのに十分な大きさであるという点です。

このバイト単位のメモリアドレッシングは、コンピュータの基本的な設計原則となっており、それが先にあります。そして、それによってデータ送受信（ネットワーク通信、ファイル読み書きなど）もバイト単位で行われるようになりました。

バイト単位でデータを送受信することは、効率的であり、エンディアン（バイト順）の問題を回避しやすく、またデータのエンコードやデコードも容易になります。したがって、ほとんどのデータは最終的にはバイトのシーケンスとして送受信されます。

したがって、メモリがバイト単位でアドレスが割り当てられるという設計が先であり、それに基づいてデータの送受信もバイト単位で行われるようになりました。

### runeとは？
Go言語における `rune` は、Unicodeコードポイントを表す型です。基本的には、`rune`は`int32`のエイリアス（別名）であり、4バイトの整数値として扱われます。

`rune`の主な用途は、Unicode文字を表現することです。UTF-8エンコードされた文字列をループ処理する際などによく使用されます。文字列の各文字は`rune`として取得でき、Unicodeコードポイントの値を直接操作できます。

以下に一例を示します：

```go
s := "こんにちは"
for i, r := range s {
    fmt.Printf("%d: %c\n", i, r)
}
```

このコードでは、文字列`s`をループし、各文字（`rune`）を取得して出力しています。`range`を使用すると、文字列の各Unicode文字を`rune`として取得できます。

ただし、`rune`は4バイトの整数値なので、全てのUnicodeコードポイント（0から0x10FFFFまで）を表現できます。したがって、有効なUnicode文字だけでなく、その範囲の任意の整数値も`rune`として扱うことが可能です。

>U+0041は4byte??
"U+0041"はUnicodeのコードポイントを表す記法で、英字の"A"を表しています。しかし、この"U+0041"自体はコードポイントを表すための表現であり、これが直接4バイトを必要とするわけではありません。

実際には、"U+0041"は16進数で41を表しており、これは10進数で65を表します。これは7ビット（具体的には6ビット）で表現可能な数値であり、必ずしも4バイト（つまり32ビット）を必要としません。

ただし、Goの`rune`型は全てのUnicodeコードポイントを表現可能であるために4バイトを使用します。Unicodeコードポイントの範囲は0から0x10FFFFまでであり、これを全て表現するには4バイト必要です。

実際の文字列データのエンコーディング（保存や送信）では、UTF-8のようなエンコーディングスキームがよく用いられます。UTF-8では、各文字を1バイトから4バイトの可変長で表現します。例えば"A"（U+0041）はUTF-8では1バイト、一方である特定の絵文字は4バイトで表現されます。

>実世界で例えると？
実世界での例を使って説明すると、次のようになります。

**Unicode**は、言葉を表現するための辞書に似ています。それぞれの単語（ここでは文字）には一意の意味（ここでは数字、またはコードポイント）が割り当てられています。たとえば、"A"という単語（文字）はU+0041という意味（コードポイント）が割り当てられています。これにより、世界中のどこでも"A"がどういう意味を持つのか（何のコードポイントを持つのか）が一貫しています。

一方、**UTF-8**はその単語（文字）を伝えるための配達人のようなものです。配達人（UTF-8）は、その単語（文字）をどのようにパッケージ化して配達するか（つまり、どのようにエンコードしてバイト列としてコンピュータに保存したりネットワークを介して送受信するか）を知っています。この配達プロセスは、文字がどの言語に属しているかによって異なります。たとえば、英字"A"は小さなパッケージ（1バイト）で配達できますが、日本語の文字"あ"はもう少し大きなパッケージ（3バイト）で配達する必要があります。

このように、UnicodeとUTF-8はそれぞれ異なる役割を持っており、共にコンピュータが世界中のあらゆる文字を一貫して扱うための重要な仕組みとなっています。

>アプリケーション開発ではどのような場面で利用されますか？
`rune` 型は特に、次のような場面でアプリケーション開発において利用されます：

1. **文字列操作**: 一部の言語（例えば日本語、中国語、アラビア語など）や絵文字は、UTF-8 エンコーディングで複数バイトを使用する文字を含む可能性があります。これらの文字列を正しく処理するためには、それらを `rune` 型のスライスとして扱うことがあります。この方法を使用すれば、文字列中の個々の文字を正確に走査したり、操作したりすることが可能になります。

    ```go
    s := "こんにちは世界"
    for _, r := range s {
        // r は rune 型で、各文字を表しています。
    }
    ```

2. **テキスト解析**: プログラムがテキストを解析する必要がある場合（たとえば、シンタックスハイライトを行うエディター、HTML や JSON パーサーなど）、個々の文字を詳細に検査する必要があります。このときに `rune` を使用すると、各文字を個々に処理することが容易になります。

3. **文字列のバリデーション**: ユーザーからの入力や外部ソースからのデータを検証する際に、特定の Unicode 文字の存在を確認する必要がある場合もあります。このようなケースでは、`rune` を使用して文字列を繰り返し処理し、特定の条件を満たすかどうかを確認します。

これらの操作は、`rune` 型を使用することで、文字列を安全かつ効率的に操作することを可能にします。なお、`rune` 型は内部的には `int32` 型なので、通常の整数操作（比較、加減算など）も適用することが可能です。

>runeがないとどうなりますか？
`rune` 型がないと、マルチバイト文字を扱う際に問題が発生する可能性があります。特に、UTF-8 でエンコードされた文字列の場合、一つの文字が複数のバイトに跨る可能性があるためです。

例えば、以下のようなコードを考えてみましょう：

```go
s := "こんにちは"
for i := 0; i < len(s); i++ {
    fmt.Printf("%c ", s[i])
}
```

このコードは期待した結果（すなわち、文字列 "こんにちは" の各文字を一つずつ出力）を返さないでしょう。なぜなら、このループは文字列をバイト単位で走査しているからです。そのため、マルチバイトの文字が分割されてしまう可能性があります。

しかし、以下のように `rune` 型を使用すると、期待通りの結果が得られます：

```go
s := "こんにちは"
for _, r := range s {
    fmt.Printf("%c ", r)
}
```

このコードでは、`range` 構文を使って文字列を走査しています。`range` は Go 言語の組み込み機能で、文字列を `rune` 型のシーケンスとして扱います。そのため、このループは文字列を Unicode 文字単位で正しく走査します。

したがって、`rune` 型がなければ、文字列を安全に操作するのが難しくなり、文字化けや予期せぬエラーを引き起こす可能性があります。

>stringからruneに変換されるとき、具体的にどのような操作が内部で行われているのですか？
Go言語で`string`から`rune`のスライスへ変換する場合、内部的にはUTF-8エンコードされた文字列がUnicodeコードポイント（runes）のシーケンスにデコードされます。以下に、このプロセスを詳細に説明します。

まず、`string`はバイトのシーケンスとして格納されます。そして、各バイトはUTF-8エンコードされた文字列の一部として解釈されます。UTF-8エンコードでは、一つの文字を表現するために1バイトから4バイトまでのバイト数を使用します。これは、その文字がASCII文字（1バイト）なのか、非ASCII文字（2バイト以上）なのかによります。

したがって、`string`から`rune`のスライスへ変換する際には、まず各バイトをチェックし、次に何バイトで一つのUnicode文字が形成されるかを判断します。そして、その一連のバイトを一つのUnicode文字（rune）として解釈し、その結果のruneのスライスを生成します。

以下に、具体的なコードを示します：

```go
s := "こんにちは"  // string (UTF-8エンコードされた文字列)
runes := []rune(s)  // runeのスライスへ変換

for i, r := range runes {
    fmt.Printf("runes[%d] = %q\n", i, r)  // 各Unicode文字を出力
}
```

このコードを実行すると、"こんにちは"という文字列中の各文字（Unicode文字）が一つずつ出力されます。これは、Go言語が内部的にUTF-8エンコードされた文字列をデコードし、それをUnicodeの文字列（runeのスライス）として扱っているためです。

>shiftjisからruneでも同じですか？
Go言語の`string`型はUTF-8エンコードされた文字列を表現することを前提としています。したがって、Shift_JISなどUTF-8以外のエンコーディング方式を使用している文字列を直接`rune`のスライスに変換しようとすると、正しくない結果を得る可能性があります。

Shift_JISエンコーディングから`rune`への変換を行うには、まずShift_JISからUTF-8への変換が必要です。Go言語では、`golang.org/x/text/encoding/japanese`パッケージを用いて、Shift_JISからUTF-8への変換が可能です。

以下に具体的なコードの例を示します：

```go
import (
	"fmt"
	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
	"io/ioutil"
	"strings"
)

func main() {
	// Shift_JISエンコーディングされた文字列
	shiftJisStr := "こんにちは（Shift_JISエンコード）"

	// Shift_JISからUTF-8に変換
	utf8Reader := transform.NewReader(strings.NewReader(shiftJisStr), japanese.ShiftJIS.NewDecoder())
	utf8StrBytes, _ := ioutil.ReadAll(utf8Reader)
	utf8Str := string(utf8StrBytes)

	// UTF-8エンコーディングされた文字列をruneのスライスに変換
	runes := []rune(utf8Str)

	for i, r := range runes {
		fmt.Printf("runes[%d] = %q\n", i, r)  // 各Unicode文字を出力
	}
}
```

このコードでは、まずShift_JISエンコーディングからUTF-8エンコーディングへの変換を行い、その後で`rune`のスライスへの変換を行っています。なお、エンコーディング変換には`golang.org/x/text/encoding/japanese`パッケージを用いています。

>runeはutf8前提であれば、utf16など来た場合は、一度utf8に変換する必要がありますか？
はい、その通りです。

>byte列で来た場合はどうでしょうか
バイト列でデータが送られてきた場合でも、そのデータを適切に解釈するためには何らかの形でエンコーディング情報が必要です。その情報がなければ、バイト列をどのように解釈すればよいか分からないからです。

例えば、バイト列がテキストを表現している場合、そのエンコーディング（UTF-8、UTF-16、Shift-JISなど）を知ることで、初めてそのバイト列を人間が理解できる文字列に変換することが可能になります。

もしそのバイト列が一部の固定フォーマット（例えば、画像や音声、特定のプロトコルのパケットなど）を表現している場合、そのフォーマットに関する情報があることで初めてバイト列を適切に解釈し、そのデータを取り扱うことが可能になります。

ただし、バイト列として送られてくるデータに対してエンコーディングやフォーマットの情報が一切与えられていない場合、そのバイト列を適切に解釈するのは非常に困難です。そういった場合は、データの送信元や使用コンテキストから何らかの手がかりを得ることが必要になるでしょう。

>送られてくるバイト列が何であるか示唆するために、同じバイト列であってもbyte型やrune型を利用することでコードが読みやすくなる認識であってますか？
はい、その認識は正しいです。バイト列の扱い方（そのバイト列をどう解釈するか）を明示的に示すために、特定の型（byteやruneなど）を利用することがあります。これによりコードが読みやすくなり、また、間違った解釈を防ぐことができます。

例えば、バイト列がUTF-8でエンコードされたテキストを表していることを示すために、そのバイト列をruneのスライスに変換することがあります。これにより、そのバイト列がテキストを表すものであること、そしてそのテキストがUTF-8でエンコードされていることが明確になります。また、runeのスライスとして扱うことで、そのテキストを文字単位で処理することが可能になります。

一方で、バイト列が特定のバイナリデータを表す場合は、それをbyteのスライスとして扱うことが一般的です。これにより、そのバイト列がバイナリデータを表すものであること、そしてそのデータをバイト単位で処理することが可能になります。

したがって、型を利用することで、バイト列の解釈方法を明示し、コードの可読性を向上させることができます。

## for, for(while), for(inf), for(range)
Go言語の`for`ループは、他のプログラミング言語と同じく反復処理を行うための重要な構造です。Goにはいくつかの異なる`for`ループの形式があります。

1. **基本的なforループ** 

    ```go
    for i := 0; i < 10; i++ {
        fmt.Println(i)
    }
    ```

    このループは、`i`が0から始まり、`i`が10未満である限り続行し、各反復後に`i`が1増加します。

2. **whileスタイルのforループ** 

    Go言語には`while`キーワードはありませんが、`for`を使って`while`ループのように動作させることができます。

    ```go
    i := 0
    for i < 10 {
        fmt.Println(i)
        i++
    }
    ```

    このループは、`i`が10未満である限り反復を続けます。

3. **無限ループ**

    ```go
    for {
        // Do something repeatedly
    }
    ```

    このループは無限に反復します。通常は内部で`break`ステートメントを使ってループを終了します。

4. **rangeキーワードを使用したforループ**

    ```go
    nums := []int{2, 3, 4, 5, 6}
    for i, num := range nums {
        fmt.Printf("index %d, value %d\n", i, num)
    }
    ```

    このループは、`nums`というスライス上でイテレーションを行います。`range`キーワードは、スライスやマップ（そして他のデータ構造）を反復するための便利な方法を提供します。

以上がGoの`for`ループの基本的な使用方法です。ループ条件やカウンタの制御により、非常に多様な反復処理を行うことができます。

## if, if(ry), switch, switch(ry)
Go言語の`if`と`switch`について説明します。

**1. ifステートメント**

Goの`if`ステートメントは、一般的なプログラミング言語と同様に条件分岐を行います。基本的な構造は以下のとおりです。

```go
if condition {
    // 処理
}
```

`if`文は指定した条件が真(`true`)のときに実行されます。また、`else if`と`else`を使ってさらに条件を追加することができます。

```go
if condition1 {
    // 条件1が真の時の処理
} else if condition2 {
    // 条件1が偽で、条件2が真の時の処理
} else {
    // 条件1と条件2がどちらも偽の時の処理
}
```

さらに、Goでは`if`文の条件部分の前に、短いステートメントを書くことができます。このステートメントで宣言された変数は、`if`のスコープ内でのみ有効です。

```go
if x := calculate(); x < 0 {
    fmt.Println("x is less than 0")
} else {
    fmt.Println("x is non-negative")
}
```

**2. switchステートメント**

`switch`ステートメントは、複数の条件を簡単に分岐させることができます。

```go
switch i {
case 0:
    fmt.Println("zero")
case 1:
    fmt.Println("one")
case 2:
    fmt.Println("two")
default:
    fmt.Println("unknown number")
}
```

上記の例では、`i`の値により出力が決まります。`default`は全ての`case`に一致しない場合に実行されます。

また、Goの`switch`では`case`の最後に`break`を書かなくても自動でそれ以上の`case`を評価しない点が他の言語とは異なります。

Goでは`if`と同じく、`switch`文の条件部分の前に短いステートメントを書くことも可能です。

```go
switch x := calculate(); x {
case 0:
    fmt.Println("zero")
case 1:
    fmt.Println("one")
default:
    fmt.Println("unknown number")
}
```

そして、条件を省略した`switch`を使うと、`true`と一致する`case`を探す挙動となり、複数の`if-else`文を短く書くのに便利です。

```go
switch {
case x < 0:
    fmt.Println("x is less than 0")
case x == 0:
    fmt.Println("x is 0")
default:
    fmt.Println("x is greater than 0")
}
```

これらはGo言語の`if`と`switch`の基本的な使い方です。他の多くの言語と同じように、これらを使ってコード内の条件分岐を制御することができます。

## Error, Panic, Recover
もちろんです。Go言語では、エラー処理とプログラムの制御フローを扱うために`error`, `panic`, `recover`という概念があります。

**1. Error**

Go言語では、エラー処理は非常に重要な役割を果たします。Goの慣習として、関数は通常、その最後の戻り値としてエラーを返します。エラーは`error`インターフェースに従っています。このインターフェースはただ一つのメソッド`Error() string`を持ちます。

エラーを作成するには、`errors`パッケージの`New`関数を使用します。

```go
err := errors.New("This is an error message")
```

そして関数がエラーを返す可能性がある場合、そのエラーをチェックして適切に対応します。

```go
result, err := someFunction()
if err != nil {
    // handle error
} else {
    // proceed as normal
}
```

**2. Panic**

`panic`はランタイムエラーが発生するときや、処理が続行できない致命的な状態を表すために用います。`panic`関数を呼び出すと、即座にプログラムの実行を停止します。

```go
panic("This is a severe error message")
```

このコードはパニックを引き起こし、エラーメッセージを出力した後、プログラムを停止します。プログラムはパニック状態から復帰することはできませんが、`defer`ステートメントを使って、パニック発生前にクリーンアップ処理を実行することが可能です。

**3. Recover**

`recover`関数は、`panic`によるパニック状態からプログラムを復帰させるためのビルトイン関数です。`recover`は`defer`ステートメント内で使用され、`panic`によって引き起こされたエラーをキャッチします。

```go
func safeFunction() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from", r)
        }
    }()
    panic("This is a severe error message")
}
```

この例では、`safeFunction`関数はパニックを引き起こしますが、`defer`ステートメントが`recover`関数を使用してパニックをキャッチし、プログラムの実行を安全に続行します。

一般的に、`panic`と`recover`はできるだけ避け、エラーを返すことでエラー状態を表現することが推奨されています。ただし、処理が続行できない程に深刻なエラーを示すために、またはAPIの一部として必要な場合に`panic`と`recover`を使用することがあります。

## Type Casting
`type casting`または型変換は、ある型の値を別の型に変換するプロセスを指します。Go 言語では、型変換は非常に厳密であり、互換性のある型間でのみ変換することができます。

Go では、型変換を行うには以下のような構文を使用します：

```go
var i int = 42
var f float64 = float64(i)
```

この例では、`int`型の`i`を`float64`型に変換しています。

型変換は値を変更せずに新しい型に変換しますが、変換の過程で情報が失われることがあります。たとえば、`float64`から`int`への変換では、小数部が切り捨てられます。

Go 言語の型変換は明示的であるため、変換したい型を明確に指定する必要があります。このアプローチは、意図しない型変換やエラーを防ぐのに役立ちます。

なお、異なる型の値を直接変換しようとするとコンパイルエラーとなりますので、型の互換性に注意する必要があります。

## packages, import and export
大文字にすると外部にexport可能
Go言語において、パッケージ（packages）のインポート（import）とエクスポート（export）はコードの構造と再利用を助ける重要な概念です。

### インポート (Import)

インポートは、他のパッケージで定義された関数、型、変数などを現在のパッケージで使用するためのメカニズムです。以下はインポートの基本的な例です：

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    fmt.Println("Square root of 16 is", math.Sqrt(16))
}
```

ここで、`fmt`と`math`パッケージがインポートされています。

### エクスポート (Export)

エクスポートは、あるパッケージから別のパッケージに型、変数、関数などを公開する方法です。Goでは、識別子（変数、関数、型など）の最初の文字が大文字である場合、その識別子はそのパッケージの外からアクセスできるようにエクスポートされます。

例：

```go
package mypackage

// ExportedFunction はエクスポートされる関数で、パッケージ外からアクセス可能
func ExportedFunction() {
    // ...
}

// unExportedFunction はエクスポートされない関数で、パッケージ外からアクセス不可能
func unExportedFunction() {
    // ...
}
```

この例では、`ExportedFunction`がエクスポートされるため、他のパッケージからアクセス可能ですが、`unExportedFunction`はエクスポートされないため、同じパッケージ内でしかアクセスできません。

このインポートとエクスポートのメカニズムにより、Goではコードの再利用、モジュール化、隠蔽が容易になり、大規模なプロジェクトの管理が助けられます。

## Type Inference（型推論）
型推論（Type Inference）は、プログラムのコンテキストから変数や式の型を自動的に推定するプロセスを指します。型推論を用いることで、プログラマーは変数の型を明示的に宣言する必要がなくなる場合があります。その結果、コードがシンプルになり、冗長性が減少します。

Go言語では、型推論は`:=`演算子を使用する際によく見られます。この演算子は、変数の宣言と同時に初期化を行い、変数の型を右側の式から推論します。

例：

```go
x := 42 // int型
y := 3.14 // float64型
z := "Hello, World!" // string型
```

上記の例では、`x`、`y`、`z`の型は右側の値から推論されます。このように、型推論を用いることでコードが簡潔になり、読みやすくなります。

しかし、型推論が適用されるのは、変数の初期化時に限られるため、全体の型システムが動的になるわけではありません。Goは静的型付け言語であり、コンパイル時に全ての変数の型が確定します。そのため、型安全性を損なうことなく、コードの冗長性を減らす助けとなります。

## Arrays
配列（Arrays）は、同じ型の値を連続して格納するためのデータ構造であり、ほとんどのプログラミング言語で見られる基本的な概念です。配列の各要素は、インデックスまたは位置によってアクセスされます。

Go言語における配列は、特定の長さを持ち、その長さは変更できません。これは、Goの配列が固定サイズであることを意味します。

配列を宣言するには、以下のように型と長さを指定します：

```go
var numbers [5]int // 長さ5のint型配列
```

配列の初期化も可能です：

```go
numbers := [5]int{10, 20, 30, 40, 50}
```

インデックスを使用して要素にアクセスしたり変更したりすることができます：

```go
firstNumber := numbers[0] // 10
numbers[1] = 25           // numbersは[10, 25, 30, 40, 50]になる
```

配列のサイズは固定なので、サイズを変更することなく要素を追加したり削除したりすることはできません。動的にサイズを変更する必要がある場合、Goではスライスと呼ばれる別のデータ構造を使用します。スライスは内部的に配列を使用しており、より柔軟に配列のように動作します。

配列は、要素の順序が重要であり、固定サイズである場合に特に役立ちます。その効率とシンプルさから、多くのプログラミングタスクで利用されています。

### []が先に来ることのメリット
ref: https://scrapbox.io/nwtgck/Go%E3%81%AE%E9%85%8D%E5%88%97%E3%82%84%E3%82%B9%E3%83%A9%E3%82%A4%E3%82%B9%E3%81%8C%5B_%5DT%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E5%85%88%E3%81%AB%5B_%5D%E3%81%8C%E6%9D%A5%E3%82%8B%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88%E3%81%A8%E3%81%97%E3%81%A6%E8%80%83%E3%81%88%E3%82%89%E3%82%8C%E3%82%8B%E3%81%93%E3%81%A8

最初は`[]`が先に来ることに違和感を感じていた。ふと以下のメリットを思った。

例えば、`[]SuperSuperLongLongLongType`のように長い型がある。
だが`[]`が先頭に書かれているのですぐに分かる。一方`[]`が後につく方は埋もれてしまう。読みやすさの面で妥当な構文に思えてきた。


[TypeScript]で型名が長い場合は`Array<SuperSuperLongLongLongType>`で短いときは`MyShortType[]`を使うみたいな同じ意味で使い分けるよりいいように思う。だが慣れのせいか、個人的には型を決めるときに配列にするかは後に決めるように訓練されたのか型をタイプしてから`[]`後からつけるように思考する傾向があるように思う。

### コンパイラ視点でのメリット


