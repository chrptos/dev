# SOLID原則
## 単一責任の原則
- クラスはたった一つのアクターに対して責務を負うべきである。
- 注意したいのは、たった一つのことをするという意味ではないということ
### 原則に違反すると？
- あるアクターのために行った変更が、別のアクターにも及び、バグが生まれてしまう可能性がある
- それぞれのアクターのテストを行い、影響範囲を確認する必要がある。
### DRYとの関係
- 同じようなロジックであっても、概念が違うものはDRYにすべきでない
- ビジネスロジックを理解していないと単一責任の原則を完全に満たすことはできない
- 初めから完全なクラスを設計することは難しいので変更に強い設計にすると良い
### チェックシート
「単一責任の原則」を満たすためのチェックリストを提供します。この原則は、一つのクラスやモジュールが一つの責任だけを持つべきである、というソフトウェア開発の基本原則です。これにより、ソフトウェアの可読性、保守性、そしてテスト容易性が向上します。

以下にそのチェックリストを示します：

1. **クラスや関数の目的を明確に定義しているか**：すべてのクラスや関数は、明確な目的を持つべきです。その目的を一文で説明できなければ、それは複数の責任を持つ可能性があります。

2. **クラスや関数が行う操作が単一のタスクに関連しているか**：クラスや関数が行うすべての操作が同じ目的を持つべきです。たとえば、ユーザー情報の管理とファイルの読み書きを同じクラスで行うべきではありません。

3. **コードの再利用性を確認する**：各クラスや関数が単一の責任を持つ場合、そのコードは再利用しやすくなります。あるクラスや関数が特定の目的でのみ利用可能な場合、それは単一の責任を持つとは言えません。

4. **コードの変更が一箇所に集中しているか**：単一の責任を持つクラスや関数は、要求が変わったときに修正が必要な箇所が一箇所に集中します。複数の箇所を修正する必要がある場合、それは複数の責任を持つ可能性があります。

5. **テストが容易であるか**：単一の責任を持つクラスや関数は、テストが容易です。あるクラスや関数が複雑なテストを必要とする場合、それは単一の責任を持たない可能性があります。

これらの項目を順に確認し、それぞれについて「はい」が答えられるようにコードを修正します。そうすることで、ソフトウェアが「単一責任の原則」に従って設計されていることを確認することができます。

## オープンクローズドの原則
- ソフトウェアのふるまいは既存の成果物を変更せずに追加できるようにするべき。
- 種別によってふるまいの変更が必要な場合
 - 会員ランク（bronse, silver, gold）
 - データ保存先の種類（rdb, nosql）
### 違反した例（分岐の追加）
```typescript
if (bronse) {
    ...
} else if (gold) {
    ...
}
```
- たとえば、masterを追加すると既存コードに修正を加える必要があるので、バグを生んでしまうかもしれない。
- 機能テストの工数が莫大になる。
### 解決策（抽象化）
- 分岐を追加するのではなくインタフェースに依存するようにする。

## リスコフの置換原則
- スーパータイプとサブタイプの継承関係が間違っているとだめ
- 「Is - a」 + 「ふるまいが同じ」というものを満たす必要がある
### 解決策
- もう一段抽象度の高いインタフェースを実装する
- 具体的な実装（つまり各クラスで利用されるメソッド実装）はサブクラスへ委ねる
## インタフェース分離の原則
- インタフェースのクライアントにとって利用しないフィールドやメソッドを強制してはならない
- インタフェースを実装するときに余計なメソッドを実装する必要が出てくるし、実装側で利用していないメソッドである場合にも修正する必要がある、そういったインタフェースは分離するべき
- 例えば、typescriptで多重実装が許されているのでインタフェースを複数に分離すればOK
## 依存性逆転の原則
- 上位モジュールは下位モジュールに依存してはならない。どちらもモジュールの「抽象」に依存すべき
- 「抽象」は実装の詳細に依存してはならない。実装の詳細が「抽象」に依存すべきである
- UserController→IUserService←UserService
- DIを利用する
### DIのデメリット
- 外部から渡すためのインスタンス生成が複雑化することがある
- コンテナ生成が外部ライブラリ依存になる言語がある
### DIコンテナとは
- 自動でDIを行ってインスタンスを構築してくれる仕組み
- 注入するインスタンスの生成が大変
```
const sample = new Sample(new Hoge(new Fuga(), new Piyo()))
```
DIコンテナにクラスと生成方法を登録しておき、DIコンテナ軽油でインスタンス化を行うことで、事前に登録しておいた状態でインスタンスを取得可能