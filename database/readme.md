## データベースの迷宮
## 失われた事実
- 履歴テーブルを作成する
- ただし、パフォーマンス劣化に注意
- 遅延レプリケーションというものがある
## やりすぎたJOIN（★★★）
- 正規化が正しくされていないとJOINがボトルネックになる
- JOINは必要最低限
- JOINテーブルは小さくしてからJOINする
- 複雑なクエリはViewを活用する
## 効かないINDEX
- B-tree
### INDEXが利用されないパターンが存在する
- 検索結果が多い、全体の件数が少ない
結果が20%未満or検索対象のテーブルが十分に大きい
- 条件にその列を使ってない
検索対象が`age * 10`となる場合は、`age`ではなく、`age * 10`となるため、インデックスが`age`に張られていても利用されない
- カーディナリティの低い列に対する検索
カーディナリティ=データの種類となるため、idなどはカーディナリティが高いと言える
- あいまいな検索
前方一致のみINDEXが利用される
- 統計情報と実際のテーブルで乖離がある場合
INDEXを利用するかどうかは、クエリ実行時にオプティマイザが判断して決めているので、統計情報が実際のテーブルと異なるとインデックスが使われない場合はある。例えば、サンプリング前に大量のデータがUPDATEされた場合など。
- まとめ
インデックスの仕様を理解して、適切に使われるようなテーブル設計やクエリを実行しよう。
## フラグの闇
- もしすべてのテーブルにフラグが追加されていたら？
- フラグによってインデックスが無効になる（カーディナリティが低い）
- データが重複する可能性がある
- クエリが複雑になる（delete_flagを条件に追加しないと*もできない）
- delete_flagで状態が変わるので、例えばnameカラムへUNIQUE制約が付けれないなど
### アンチパターンを生まないために
- 事実のみを保存する（deletedテーブルを作成する）
### 「状態」を持たせるのは絶対にだめ？
- 対象テーブルが小さくて、INDEX不要であればOK
- 親テーブルにならなければJOINしないのでOK
- UNIQUE制約が不要、もし外部キー制約で利用するならUNIQUEが必要
### フラグの闇はあとあと効いてくる（★★★）
- statusカラムは、where句で利用したり、if文でチェックする必要は発生する。
- 送信ステータスは、メルマガを送る場合に送信済みメールも対象テーブルに残るためテーブルが肥大化する。将来的にパフォーマンスのボトルネックとなる。設計によっては、排他的な行ロックを取って管理する必要がある。（mall_listをselectするときにfor updateする必要が出てくる。）
## ソートの依存（★★★）
- リレーショナルモデルには重複がない、NULLがない、順番がない。{1,2,3}と{3,2,1}は同じもの。
- RDBMSとエグゼキュータによるとORDER BYは最後から2番目に実行されるので、データが多くなればなるほど重い処理になる。
### 対策
- 次のページに渡すのはOFFSETではなく、最後に表示された行のIDにする。（WHERE句にIDを指定できるのでINDEXを用いて速度向上できる）
- 先述したとおり、リレーショナルモデルにはソートの概念が元々存在しないため、アプリケーション側でソートするという解決策もある。ただし、データ一覧をアプリにすべて渡す必要があり、通信に負荷がかかるので注意する。
- NoSQLを利用する。近年では一般的になりつつある。Redisはすべてのデータをメモリ上で処理するため非常に高速で、キャッシュ、セッション管理、キューやソートといった場面でよく利用されている。
## 隠された状態

